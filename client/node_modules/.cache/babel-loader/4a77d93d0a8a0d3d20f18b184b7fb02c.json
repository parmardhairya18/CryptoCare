{"ast":null,"code":"'use strict';\n\nconst Qs = require('qs');\n\nconst qsDefaultEncoder = require('qs/lib/utils').encode;\n\nconst isNode = require('detect-node');\n\nconst ndjson = require('ndjson');\n\nconst pump = require('pump');\n\nconst once = require('once');\n\nconst streamToValue = require('./stream-to-value');\n\nconst streamToJsonValue = require('./stream-to-json-value');\n\nconst request = require('./request');\n\nconst log = require('debug')('ipfs-api:request'); // -- Internal\n\n\nfunction parseError(res, cb) {\n  const error = new Error(`Server responded with ${res.statusCode}`);\n  streamToJsonValue(res, (err, payload) => {\n    if (err) {\n      return cb(err);\n    }\n\n    if (payload) {\n      error.code = payload.Code;\n      error.message = payload.Message || payload.toString();\n      error.type = payload.Type;\n    }\n\n    cb(error);\n  });\n}\n\nfunction onRes(buffer, cb) {\n  return res => {\n    const stream = Boolean(res.headers['x-stream-output']);\n    const chunkedObjects = Boolean(res.headers['x-chunked-output']);\n    const isJson = res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') === 0;\n\n    if (res.req) {\n      log(res.req.method, `${res.req.getHeaders().host}${res.req.path}`, res.statusCode, res.statusMessage);\n    } else {\n      log(res.url, res.statusCode, res.statusMessage);\n    }\n\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb);\n    } // Return the response stream directly\n\n\n    if (stream && !buffer) {\n      return cb(null, res);\n    } // Return a stream of JSON objects\n\n\n    if (chunkedObjects && isJson) {\n      const outputStream = ndjson.parse();\n      pump(res, outputStream);\n      res.on('end', () => {\n        let err = res.trailers['x-stream-error'];\n\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err);\n          } catch (e) {\n            err = {\n              Message: err\n            };\n          }\n\n          outputStream.emit('error', new Error(err.Message));\n        }\n      });\n      return cb(null, outputStream);\n    } // Return a JSON object\n\n\n    if (isJson) {\n      return streamToJsonValue(res, cb);\n    } // Return a value\n\n\n    return streamToValue(res, cb);\n  };\n}\n\nfunction requestAPI(config, options, callback) {\n  callback = once(callback);\n  options.qs = options.qs || {};\n\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/');\n  }\n\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args];\n  }\n\n  if (options.args) {\n    options.qs.arg = options.args;\n  }\n\n  if (options.progress) {\n    options.qs.progress = true;\n  }\n\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r; // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n\n    delete options.qs.r;\n  }\n\n  options.qs['stream-channels'] = true;\n\n  if (options.stream) {\n    options.buffer = false;\n  } // this option is only used internally, not passed to daemon\n\n\n  delete options.qs.followSymlinks;\n  const method = 'POST';\n  const headers = Object.assign({}, config.headers);\n\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent'];\n  }\n\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'));\n    }\n\n    headers['Content-Type'] = `multipart/form-data; boundary=${options.multipartBoundary}`;\n  }\n\n  const qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: data => {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        let uriEncoded = '';\n\n        for (const byte of data) {\n          // https://tools.ietf.org/html/rfc3986#page-14\n          // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n          if (byte >= 0x41 && byte <= 0x5A || byte >= 0x61 && byte <= 0x7A || byte >= 0x30 && byte <= 0x39 || byte === 0x2D || byte === 0x2E || byte === 0x5F || byte === 0x7E) {\n            uriEncoded += String.fromCharCode(byte);\n          } else {\n            const hex = byte.toString(16); // String.prototype.padStart() not widely supported yet\n\n            const padded = hex.length === 1 ? `0${hex}` : hex;\n            uriEncoded += `%${padded}`;\n          }\n        }\n\n        return uriEncoded;\n      }\n\n      return qsDefaultEncoder(data);\n    }\n  });\n  const reqOptions = {\n    hostname: config.host,\n    path: `${config['api-path']}${options.path}?${qs}`,\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: `${config.protocol}:`\n  };\n  const req = request(config.protocol)(reqOptions, onRes(options.buffer, callback));\n  req.on('error', err => {\n    callback(err);\n  });\n\n  if (!options.stream) {\n    req.end();\n  }\n\n  return req;\n} //\n// -- Module Interface\n\n\nexports = module.exports = config => {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  const send = (options, callback) => {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'));\n    }\n\n    return requestAPI(config, options, callback);\n  }; // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n\n\n  send.andTransform = (options, transform, callback) => {\n    return send(options, (err, res) => {\n      if (err) {\n        return callback(err);\n      }\n\n      transform(res, callback);\n    });\n  };\n\n  return send;\n};","map":{"version":3,"names":["Qs","require","qsDefaultEncoder","encode","isNode","ndjson","pump","once","streamToValue","streamToJsonValue","request","log","parseError","res","cb","error","Error","statusCode","err","payload","code","Code","message","Message","toString","type","Type","onRes","buffer","stream","Boolean","headers","chunkedObjects","isJson","indexOf","req","method","getHeaders","host","path","statusMessage","url","outputStream","parse","on","trailers","JSON","e","emit","requestAPI","config","options","callback","qs","Array","isArray","join","args","arg","progress","r","recursive","followSymlinks","Object","assign","multipart","multipartBoundary","stringify","arrayFormat","encoder","data","Buffer","isBuffer","uriEncoded","byte","String","fromCharCode","hex","padded","length","reqOptions","hostname","port","protocol","end","exports","module","send","andTransform","transform"],"sources":["R:/New_Block/client/node_modules/ipfs-api/src/utils/send-request.js"],"sourcesContent":["'use strict'\n\nconst Qs = require('qs')\nconst qsDefaultEncoder = require('qs/lib/utils').encode\nconst isNode = require('detect-node')\nconst ndjson = require('ndjson')\nconst pump = require('pump')\nconst once = require('once')\nconst streamToValue = require('./stream-to-value')\nconst streamToJsonValue = require('./stream-to-json-value')\nconst request = require('./request')\nconst log = require('debug')('ipfs-api:request')\n\n// -- Internal\n\nfunction parseError (res, cb) {\n  const error = new Error(`Server responded with ${res.statusCode}`)\n\n  streamToJsonValue(res, (err, payload) => {\n    if (err) {\n      return cb(err)\n    }\n\n    if (payload) {\n      error.code = payload.Code\n      error.message = payload.Message || payload.toString()\n      error.type = payload.Type\n    }\n    cb(error)\n  })\n}\n\nfunction onRes (buffer, cb) {\n  return (res) => {\n    const stream = Boolean(res.headers['x-stream-output'])\n    const chunkedObjects = Boolean(res.headers['x-chunked-output'])\n    const isJson = res.headers['content-type'] &&\n                   res.headers['content-type'].indexOf('application/json') === 0\n\n    if (res.req) {\n      log(res.req.method, `${res.req.getHeaders().host}${res.req.path}`, res.statusCode, res.statusMessage)\n    } else {\n      log(res.url, res.statusCode, res.statusMessage)\n    }\n\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb)\n    }\n\n    // Return the response stream directly\n    if (stream && !buffer) {\n      return cb(null, res)\n    }\n\n    // Return a stream of JSON objects\n    if (chunkedObjects && isJson) {\n      const outputStream = ndjson.parse()\n      pump(res, outputStream)\n      res.on('end', () => {\n        let err = res.trailers['x-stream-error']\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err)\n          } catch (e) {\n            err = { Message: err }\n          }\n          outputStream.emit('error', new Error(err.Message))\n        }\n      })\n      return cb(null, outputStream)\n    }\n\n    // Return a JSON object\n    if (isJson) {\n      return streamToJsonValue(res, cb)\n    }\n\n    // Return a value\n    return streamToValue(res, cb)\n  }\n}\n\nfunction requestAPI (config, options, callback) {\n  callback = once(callback)\n  options.qs = options.qs || {}\n\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/')\n  }\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args]\n  }\n  if (options.args) {\n    options.qs.arg = options.args\n  }\n  if (options.progress) {\n    options.qs.progress = true\n  }\n\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r\n    // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n    delete options.qs.r\n  }\n\n  options.qs['stream-channels'] = true\n\n  if (options.stream) {\n    options.buffer = false\n  }\n\n  // this option is only used internally, not passed to daemon\n  delete options.qs.followSymlinks\n\n  const method = 'POST'\n  const headers = Object.assign({}, config.headers)\n\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent']\n  }\n\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'))\n    }\n\n    headers['Content-Type'] = `multipart/form-data; boundary=${options.multipartBoundary}`\n  }\n\n  const qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: data => {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        let uriEncoded = ''\n        for (const byte of data) {\n          // https://tools.ietf.org/html/rfc3986#page-14\n          // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n          if (\n            (byte >= 0x41 && byte <= 0x5A) ||\n            (byte >= 0x61 && byte <= 0x7A) ||\n            (byte >= 0x30 && byte <= 0x39) ||\n            (byte === 0x2D) ||\n            (byte === 0x2E) ||\n            (byte === 0x5F) ||\n            (byte === 0x7E)\n          ) {\n            uriEncoded += String.fromCharCode(byte)\n          } else {\n            const hex = byte.toString(16)\n            // String.prototype.padStart() not widely supported yet\n            const padded = hex.length === 1 ? `0${hex}` : hex\n            uriEncoded += `%${padded}`\n          }\n        }\n        return uriEncoded\n      }\n      return qsDefaultEncoder(data)\n    }\n  })\n  const reqOptions = {\n    hostname: config.host,\n    path: `${config['api-path']}${options.path}?${qs}`,\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: `${config.protocol}:`\n  }\n\n  const req = request(config.protocol)(reqOptions, onRes(options.buffer, callback))\n\n  req.on('error', (err) => {\n    callback(err)\n  })\n\n  if (!options.stream) {\n    req.end()\n  }\n\n  return req\n}\n\n//\n// -- Module Interface\n\nexports = module.exports = (config) => {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  const send = (options, callback) => {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'))\n    }\n\n    return requestAPI(config, options, callback)\n  }\n\n  // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n  send.andTransform = (options, transform, callback) => {\n    return send(options, (err, res) => {\n      if (err) {\n        return callback(err)\n      }\n      transform(res, callback)\n    })\n  }\n\n  return send\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}