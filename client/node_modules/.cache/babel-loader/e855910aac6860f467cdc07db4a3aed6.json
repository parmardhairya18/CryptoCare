{"ast":null,"code":"'use strict';\n\nconst Duplex = require('stream').Duplex;\n\nconst eachSeries = require('async/eachSeries');\n\nconst isStream = require('is-stream');\n\nconst once = require('once');\n\nconst prepareFile = require('./prepare-file');\n\nconst Multipart = require('./multipart');\n\nfunction headers(file) {\n  const name = file.path ? encodeURIComponent(file.path) : '';\n  const header = {\n    'Content-Disposition': `file; filename=\"${name}\"`\n  };\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory';\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink';\n  } else {\n    header['Content-Type'] = 'application/octet-stream';\n  }\n\n  return header;\n}\n\nmodule.exports = (send, path) => {\n  return options => {\n    let request;\n    let ended = false;\n    let writing = false;\n    options = options ? Object.assign({}, options, options.qs) : {};\n    const multipart = new Multipart();\n    const retStream = new Duplex({\n      objectMode: true\n    });\n\n    retStream._read = n => {};\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next);\n\n      try {\n        const files = prepareFile(file, options).map(file => Object.assign({\n          headers: headers(file)\n        }, file));\n        writing = true;\n        eachSeries(files, (file, cb) => multipart.write(file, enc, cb), err => {\n          writing = false;\n\n          if (err) {\n            return next(err);\n          }\n\n          if (ended) {\n            multipart.end();\n          }\n\n          next();\n        });\n      } catch (err) {\n        next(err);\n      }\n    };\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true;\n\n        if (!writing) {\n          multipart.end();\n        }\n      }\n    });\n    const qs = options.qs || {};\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion');\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves');\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash');\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory');\n    qs.hash = propOrProp(options, 'hash', 'hashAlg');\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    };\n    multipart.on('error', err => {\n      retStream.emit('error', err);\n    });\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err);\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null); // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response);\n        retStream.push(null);\n        return;\n      }\n\n      response.on('error', err => retStream.emit('error', err));\n\n      if (options.converter) {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n        });\n        const Converter = options.converter;\n        const convertedResponse = new Converter();\n        convertedResponse.once('end', () => retStream.push(null));\n        convertedResponse.on('data', d => retStream.push(d));\n        response.pipe(convertedResponse);\n      } else {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n\n          retStream.push(d);\n        });\n        response.once('end', () => retStream.push(null));\n      }\n    }); // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n\n    request.on('drain', () => multipart.emit('drain'));\n    multipart.pipe(request);\n    return retStream;\n  };\n};\n\nfunction propOrProp(source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1];\n  } else if (prop2 in source) {\n    return source[prop2];\n  }\n}","map":{"version":3,"names":["Duplex","require","eachSeries","isStream","once","prepareFile","Multipart","headers","file","name","path","encodeURIComponent","header","content","symlink","module","exports","send","options","request","ended","writing","Object","assign","qs","multipart","retStream","objectMode","_read","n","_write","enc","_next","next","files","map","cb","write","err","end","propOrProp","hash","args","multipartBoundary","_boundary","stream","recursive","progress","on","emit","response","push","converter","d","Bytes","Converter","convertedResponse","pipe","source","prop1","prop2"],"sources":["R:/New_Block/client/node_modules/ipfs-api/src/utils/send-files-stream.js"],"sourcesContent":["'use strict'\n\nconst Duplex = require('stream').Duplex\nconst eachSeries = require('async/eachSeries')\nconst isStream = require('is-stream')\nconst once = require('once')\nconst prepareFile = require('./prepare-file')\nconst Multipart = require('./multipart')\n\nfunction headers (file) {\n  const name = file.path\n    ? encodeURIComponent(file.path)\n    : ''\n\n  const header = { 'Content-Disposition': `file; filename=\"${name}\"` }\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory'\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink'\n  } else {\n    header['Content-Type'] = 'application/octet-stream'\n  }\n\n  return header\n}\n\nmodule.exports = (send, path) => {\n  return (options) => {\n    let request\n    let ended = false\n    let writing = false\n\n    options = options ? Object.assign({}, options, options.qs) : {}\n\n    const multipart = new Multipart()\n\n    const retStream = new Duplex({ objectMode: true })\n\n    retStream._read = (n) => {}\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next)\n      try {\n        const files = prepareFile(file, options)\n          .map((file) => Object.assign({headers: headers(file)}, file))\n\n        writing = true\n        eachSeries(\n          files,\n          (file, cb) => multipart.write(file, enc, cb),\n          (err) => {\n            writing = false\n            if (err) {\n              return next(err)\n            }\n            if (ended) {\n              multipart.end()\n            }\n            next()\n          })\n      } catch (err) {\n        next(err)\n      }\n    }\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true\n        if (!writing) {\n          multipart.end()\n        }\n      }\n    })\n\n    const qs = options.qs || {}\n\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion')\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves')\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash')\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory')\n    qs.hash = propOrProp(options, 'hash', 'hashAlg')\n\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    }\n\n    multipart.on('error', (err) => {\n      retStream.emit('error', err)\n    })\n\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err)\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null) // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response)\n        retStream.push(null)\n        return\n      }\n\n      response.on('error', (err) => retStream.emit('error', err))\n\n      if (options.converter) {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n        })\n\n        const Converter = options.converter\n        const convertedResponse = new Converter()\n        convertedResponse.once('end', () => retStream.push(null))\n        convertedResponse.on('data', (d) => retStream.push(d))\n        response.pipe(convertedResponse)\n      } else {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n          retStream.push(d)\n        })\n        response.once('end', () => retStream.push(null))\n      }\n    })\n\n    // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n    request.on('drain', () => multipart.emit('drain'))\n\n    multipart.pipe(request)\n\n    return retStream\n  }\n}\n\nfunction propOrProp (source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1]\n  } else if (prop2 in source) {\n    return source[prop2]\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}