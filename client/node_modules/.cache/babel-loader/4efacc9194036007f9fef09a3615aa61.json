{"ast":null,"code":"'use strict';\n\nconst multihashing = require('multihashing-async');\n\nconst protobuf = require('protons');\n\nconst bs58 = require('bs58');\n\nconst crypto = require('./rsa');\n\nconst pbm = protobuf(require('./keys.proto'));\n\nconst forge = require('node-forge');\n\nconst setImmediate = require('async/setImmediate');\n\nclass RsaPublicKey {\n  constructor(key) {\n    this._key = key;\n  }\n\n  verify(data, sig, callback) {\n    ensure(callback);\n    crypto.hashAndVerify(this._key, sig, data, callback);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkix(this._key);\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    });\n  }\n\n  encrypt(bytes) {\n    return this._key.encrypt(bytes, 'RSAES-PKCS1-V1_5');\n  }\n\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n\n  hash(callback) {\n    ensure(callback);\n    multihashing(this.bytes, 'sha2-256', callback);\n  }\n\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Buffer of the spki format\n  constructor(key, publicKey) {\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n\n  genSecret() {\n    return crypto.getRandomValues(new Uint8Array(16));\n  }\n\n  sign(message, callback) {\n    ensure(callback);\n    crypto.hashAndSign(this._key, message, callback);\n  }\n\n  get public() {\n    if (!this._publicKey) {\n      throw new Error('public key not provided');\n    }\n\n    return new RsaPublicKey(this._publicKey);\n  }\n\n  decrypt(msg, callback) {\n    crypto.decrypt(this._key, msg, callback);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkcs1(this._key);\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n\n  hash(callback) {\n    ensure(callback);\n    multihashing(this.bytes, 'sha2-256', callback);\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @param {function(Error, id)} callback\n   * @returns {undefined}\n   */\n\n\n  id(callback) {\n    this.public.hash((err, hash) => {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, bs58.encode(hash));\n    });\n  }\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} [format] - Defaults to 'pkcs-8'.\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n\n\n  export(format, password, callback) {\n    if (typeof password === 'function') {\n      callback = password;\n      password = format;\n      format = 'pkcs-8';\n    }\n\n    ensure(callback);\n    setImmediate(() => {\n      let err = null;\n      let pem = null;\n\n      try {\n        const buffer = new forge.util.ByteBuffer(this.marshal());\n        const asn1 = forge.asn1.fromDer(buffer);\n        const privateKey = forge.pki.privateKeyFromAsn1(asn1);\n\n        if (format === 'pkcs-8') {\n          const options = {\n            algorithm: 'aes256',\n            count: 10000,\n            saltSize: 128 / 8,\n            prfAlgorithm: 'sha512'\n          };\n          pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options);\n        } else {\n          err = new Error(`Unknown export format '${format}'`);\n        }\n      } catch (_err) {\n        err = _err;\n      }\n\n      callback(err, pem);\n    });\n  }\n\n}\n\nfunction unmarshalRsaPrivateKey(bytes, callback) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes);\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\n\nfunction unmarshalRsaPublicKey(bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\n\nfunction fromJwk(jwk, callback) {\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\n\nfunction generateKeyPair(bits, callback) {\n  crypto.generateKey(bits, (err, keys) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\n\nfunction ensure(callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n};","map":{"version":3,"names":["multihashing","require","protobuf","bs58","crypto","pbm","forge","setImmediate","RsaPublicKey","constructor","key","_key","verify","data","sig","callback","ensure","hashAndVerify","marshal","utils","jwkToPkix","bytes","PublicKey","encode","Type","KeyType","RSA","Data","encrypt","equals","hash","RsaPrivateKey","publicKey","_publicKey","genSecret","getRandomValues","Uint8Array","sign","message","hashAndSign","public","Error","decrypt","msg","jwkToPkcs1","PrivateKey","id","err","export","format","password","pem","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","_err","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","unmarshalPrivateKey","keys","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey","module","exports"],"sources":["R:/New_Block/client/node_modules/ipfs-api/node_modules/libp2p-crypto/src/keys/rsa-class.js"],"sourcesContent":["'use strict'\n\nconst multihashing = require('multihashing-async')\nconst protobuf = require('protons')\nconst bs58 = require('bs58')\n\nconst crypto = require('./rsa')\nconst pbm = protobuf(require('./keys.proto'))\nconst forge = require('node-forge')\nconst setImmediate = require('async/setImmediate')\n\nclass RsaPublicKey {\n  constructor (key) {\n    this._key = key\n  }\n\n  verify (data, sig, callback) {\n    ensure(callback)\n    crypto.hashAndVerify(this._key, sig, data, callback)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    })\n  }\n\n  encrypt (bytes) {\n    return this._key.encrypt(bytes, 'RSAES-PKCS1-V1_5')\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  hash (callback) {\n    ensure(callback)\n    multihashing(this.bytes, 'sha2-256', callback)\n  }\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Buffer of the spki format\n  constructor (key, publicKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret () {\n    return crypto.getRandomValues(new Uint8Array(16))\n  }\n\n  sign (message, callback) {\n    ensure(callback)\n    crypto.hashAndSign(this._key, message, callback)\n  }\n\n  get public () {\n    if (!this._publicKey) {\n      throw new Error('public key not provided')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (msg, callback) {\n    crypto.decrypt(this._key, msg, callback)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  hash (callback) {\n    ensure(callback)\n    multihashing(this.bytes, 'sha2-256', callback)\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @param {function(Error, id)} callback\n   * @returns {undefined}\n   */\n  id (callback) {\n    this.public.hash((err, hash) => {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, bs58.encode(hash))\n    })\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} [format] - Defaults to 'pkcs-8'.\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n  export (format, password, callback) {\n    if (typeof password === 'function') {\n      callback = password\n      password = format\n      format = 'pkcs-8'\n    }\n\n    ensure(callback)\n\n    setImmediate(() => {\n      let err = null\n      let pem = null\n      try {\n        const buffer = new forge.util.ByteBuffer(this.marshal())\n        const asn1 = forge.asn1.fromDer(buffer)\n        const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n\n        if (format === 'pkcs-8') {\n          const options = {\n            algorithm: 'aes256',\n            count: 10000,\n            saltSize: 128 / 8,\n            prfAlgorithm: 'sha512'\n          }\n          pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n        } else {\n          err = new Error(`Unknown export format '${format}'`)\n        }\n      } catch (_err) {\n        err = _err\n      }\n\n      callback(err, pem)\n    })\n  }\n}\n\nfunction unmarshalRsaPrivateKey (bytes, callback) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\n  })\n}\n\nfunction unmarshalRsaPublicKey (bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n\n  return new RsaPublicKey(jwk)\n}\n\nfunction fromJwk (jwk, callback) {\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\n  })\n}\n\nfunction generateKeyPair (bits, callback) {\n  crypto.generateKey(bits, (err, keys) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\n  })\n}\n\nfunction ensure (callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}