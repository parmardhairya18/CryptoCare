{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nconst mh = require('multihashes');\n\nconst crypto = require('libp2p-crypto');\n\nconst assert = require('assert');\n\nconst waterfall = require('async/waterfall');\n\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided');\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n\n  get privKey() {\n    return this._privKey;\n  }\n\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n  }\n\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return crypto.keys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return crypto.keys.marshalPrivateKey(this.privKey);\n    }\n  } // pretty print\n\n\n  toPrint() {\n    return this.toJSON();\n  } // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n\n\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  } // encode/decode functions\n\n\n  toHexString() {\n    return mh.toHexString(this.id);\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return this._idB58String;\n  }\n\n  isEqual(id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id);\n    } else if (id.id) {\n      return this.id.equals(id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid(callback) {\n    // TODO Needs better checking\n    if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback();\n    } else {\n      callback(new Error('Keys not match'));\n    }\n  }\n\n}\n\nexports = module.exports = PeerId; // generation\n\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  waterfall([cb => crypto.keys.generateKeyPair('RSA', opts.bits, cb), (privKey, cb) => privKey.public.hash((err, digest) => {\n    cb(err, digest, privKey);\n  })], (err, digest, privKey) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new PeerId(digest, privKey));\n  });\n};\n\nexports.createFromHexString = function (str) {\n  return new PeerId(mh.fromHexString(str));\n};\n\nexports.createFromBytes = function (buf) {\n  return new PeerId(buf);\n};\n\nexports.createFromB58String = function (str) {\n  return new PeerId(mh.fromB58String(str));\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let pubKey;\n\n  try {\n    let buf = key;\n\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n    pubKey = crypto.keys.unmarshalPublicKey(buf);\n  } catch (err) {\n    return callback(err);\n  }\n\n  pubKey.hash((err, digest) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new PeerId(digest, null, pubKey));\n  });\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let buf = key;\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n  } catch (err) {\n    return callback(err);\n  }\n\n  waterfall([cb => crypto.keys.unmarshalPrivateKey(buf, cb), (privKey, cb) => privKey.public.hash((err, digest) => {\n    cb(err, digest, privKey);\n  })], (err, digest, privKey) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new PeerId(digest, privKey, privKey.public));\n  });\n};\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let id;\n  let rawPrivKey;\n  let rawPubKey;\n  let pub;\n\n  try {\n    id = mh.fromB58String(obj.id);\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n    pub = rawPubKey && crypto.keys.unmarshalPublicKey(rawPubKey);\n  } catch (err) {\n    return callback(err);\n  }\n\n  if (rawPrivKey) {\n    waterfall([cb => crypto.keys.unmarshalPrivateKey(rawPrivKey, cb), (priv, cb) => priv.public.hash((err, digest) => {\n      cb(err, digest, priv);\n    }), (privDigest, priv, cb) => {\n      if (pub) {\n        pub.hash((err, pubDigest) => {\n          cb(err, privDigest, priv, pubDigest);\n        });\n      } else {\n        cb(null, privDigest, priv);\n      }\n    }], (err, privDigest, priv, pubDigest) => {\n      if (err) {\n        return callback(err);\n      }\n\n      if (pub && !privDigest.equals(pubDigest)) {\n        return callback(new Error('Public and private key do not match'));\n      }\n\n      if (id && !privDigest.equals(id)) {\n        return callback(new Error('Id and private key do not match'));\n      }\n\n      callback(null, new PeerId(id, priv, pub));\n    });\n  } else {\n    callback(null, new PeerId(id, null, pub));\n  }\n};\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"names":["mh","require","crypto","assert","waterfall","PeerId","constructor","id","privKey","pubKey","Buffer","isBuffer","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","val","Error","marshalPubKey","keys","marshalPublicKey","marshalPrivKey","marshalPrivateKey","toPrint","toJSON","toB64Opt","toHexString","toBytes","isEqual","isValid","callback","exports","module","create","opts","bits","cb","generateKeyPair","hash","err","digest","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","fromB58String","createFromPubKey","key","from","unmarshalPublicKey","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","priv","privDigest","pubDigest","isPeerId","peerId","Boolean","toString"],"sources":["R:/CryptoCare/client/node_modules/ipfs-api/node_modules/peer-info/node_modules/peer-id/src/index.js"],"sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst mh = require('multihashes')\nconst crypto = require('libp2p-crypto')\nconst assert = require('assert')\nconst waterfall = require('async/waterfall')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided')\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return crypto.keys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return crypto.keys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  // pretty print\n  toPrint () {\n    return this.toJSON()\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  isEqual (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid (callback) {\n    // TODO Needs better checking\n    if (this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback()\n    } else {\n      callback(new Error('Keys not match'))\n    }\n  }\n}\n\nexports = module.exports = PeerId\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  }\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n\n  waterfall([\n    (cb) => crypto.keys.generateKeyPair('RSA', opts.bits, cb),\n    (privKey, cb) => privKey.public.hash((err, digest) => {\n      cb(err, digest, privKey)\n    })\n  ], (err, digest, privKey) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, privKey))\n  })\n}\n\nexports.createFromHexString = function (str) {\n  return new PeerId(mh.fromHexString(str))\n}\n\nexports.createFromBytes = function (buf) {\n  return new PeerId(buf)\n}\n\nexports.createFromB58String = function (str) {\n  return new PeerId(mh.fromB58String(str))\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let pubKey\n\n  try {\n    let buf = key\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n\n    pubKey = crypto.keys.unmarshalPublicKey(buf)\n  } catch (err) {\n    return callback(err)\n  }\n\n  pubKey.hash((err, digest) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, null, pubKey))\n  })\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let buf = key\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n  } catch (err) {\n    return callback(err)\n  }\n\n  waterfall([\n    (cb) => crypto.keys.unmarshalPrivateKey(buf, cb),\n    (privKey, cb) => privKey.public.hash((err, digest) => {\n      cb(err, digest, privKey)\n    })\n  ], (err, digest, privKey) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, privKey, privKey.public))\n  })\n}\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let id\n  let rawPrivKey\n  let rawPubKey\n  let pub\n\n  try {\n    id = mh.fromB58String(obj.id)\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n    pub = rawPubKey && crypto.keys.unmarshalPublicKey(rawPubKey)\n  } catch (err) {\n    return callback(err)\n  }\n\n  if (rawPrivKey) {\n    waterfall([\n      (cb) => crypto.keys.unmarshalPrivateKey(rawPrivKey, cb),\n      (priv, cb) => priv.public.hash((err, digest) => {\n        cb(err, digest, priv)\n      }),\n      (privDigest, priv, cb) => {\n        if (pub) {\n          pub.hash((err, pubDigest) => {\n            cb(err, privDigest, priv, pubDigest)\n          })\n        } else {\n          cb(null, privDigest, priv)\n        }\n      }\n    ], (err, privDigest, priv, pubDigest) => {\n      if (err) {\n        return callback(err)\n      }\n\n      if (pub && !privDigest.equals(pubDigest)) {\n        return callback(new Error('Public and private key do not match'))\n      }\n\n      if (id && !privDigest.equals(id)) {\n        return callback(new Error('Id and private key do not match'))\n      }\n\n      callback(null, new PeerId(id, priv, pub))\n    })\n  } else {\n    callback(null, new PeerId(id, null, pub))\n  }\n}\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}