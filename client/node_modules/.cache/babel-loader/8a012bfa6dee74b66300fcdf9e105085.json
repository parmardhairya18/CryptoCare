{"ast":null,"code":"'use strict';\n\nconst waterfall = require('async/waterfall');\n\nconst CID = require('cids');\n\nconst util = require('./util');\n\nexports = module.exports;\nexports.multicodec = 'dag-pb';\nexports.defaultHashAlg = 'sha2-256';\n/*\n * resolve: receives a path and a binary blob and returns the value on path,\n * throw if not possible. `binaryBlob` is the ProtocolBuffer encoded data.\n */\n\nexports.resolve = (binaryBlob, path, callback) => {\n  waterfall([cb => util.deserialize(binaryBlob, cb), (node, cb) => {\n    // Return the deserialized block if no path is given\n    if (!path) {\n      return callback(null, {\n        value: node,\n        remainderPath: ''\n      });\n    }\n\n    const split = path.split('/');\n\n    if (split[0] === 'Links') {\n      let remainderPath = ''; // all links\n\n      if (!split[1]) {\n        return cb(null, {\n          value: node.links.map(l => l.toJSON()),\n          remainderPath: ''\n        });\n      } // select one link\n\n\n      const values = {}; // populate both index number and name to enable both cases\n      // for the resolver\n\n      node.links.forEach((l, i) => {\n        const link = l.toJSON();\n        values[i] = values[link.name] = {\n          hash: link.multihash,\n          name: link.name,\n          size: link.size\n        };\n      });\n      let value = values[split[1]]; // if remainderPath exists, value needs to be CID\n\n      if (split[2] === 'Hash') {\n        value = {\n          '/': value.hash\n        };\n      } else if (split[2] === 'Tsize') {\n        value = value.size;\n      } else if (split[2] === 'Name') {\n        value = value.name;\n      }\n\n      remainderPath = split.slice(3).join('/');\n      cb(null, {\n        value: value,\n        remainderPath: remainderPath\n      });\n    } else if (split[0] === 'Data') {\n      cb(null, {\n        value: node.data,\n        remainderPath: ''\n      });\n    } else {\n      // If split[0] is not 'Data' or 'Links' then we might be trying to refer\n      // to a named link from the Links array. This is because go-ipfs and\n      // js-ipfs have historically supported the ability to do\n      // `ipfs dag get CID/a` where a is a named link in a dag-pb.\n      const values = {};\n      node.links.forEach((l, i) => {\n        const link = l.toJSON();\n        values[link.name] = {\n          hash: link.multihash,\n          name: link.name,\n          size: link.size\n        };\n      });\n      const value = values[split[0]];\n\n      if (value) {\n        return cb(null, {\n          value: {\n            '/': value.hash\n          },\n          remainderPath: split.slice(1).join('/')\n        });\n      }\n\n      cb(new Error('path not available'));\n    }\n  }], callback);\n};\n/*\n * tree: returns a flattened array with paths: values of the project. options\n * is an object that can carry several options (i.e. nestness)\n */\n\n\nexports.tree = (binaryBlob, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  util.deserialize(binaryBlob, (err, node) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const paths = [];\n    paths.push('Links');\n    node.links.forEach((link, i) => {\n      paths.push(`Links/${i}/Name`);\n      paths.push(`Links/${i}/Tsize`);\n      paths.push(`Links/${i}/Hash`);\n    });\n    paths.push('Data');\n    callback(null, paths);\n  });\n};\n/*\n * isLink: returns the Link if a given path in a binary blob is a Link,\n * false otherwise\n */\n\n\nexports.isLink = (binaryBlob, path, callback) => {\n  exports.resolve(binaryBlob, path, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (result.remainderPath.length > 0) {\n      return callback(new Error('path out of scope'));\n    }\n\n    if (typeof result.value === 'object' && result.value['/']) {\n      let valid;\n\n      try {\n        valid = CID.isCID(new CID(result.value['/']));\n      } catch (err) {\n        valid = false;\n      }\n\n      if (valid) {\n        return callback(null, result.value);\n      }\n    }\n\n    callback(null, false);\n  });\n};","map":{"version":3,"names":["waterfall","require","CID","util","exports","module","multicodec","defaultHashAlg","resolve","binaryBlob","path","callback","cb","deserialize","node","value","remainderPath","split","links","map","l","toJSON","values","forEach","i","link","name","hash","multihash","size","slice","join","data","Error","tree","options","err","paths","push","isLink","result","length","valid","isCID"],"sources":["R:/CryptoCare/client/node_modules/ipfs-api/node_modules/ipld-dag-pb/src/resolver.js"],"sourcesContent":["'use strict'\n\nconst waterfall = require('async/waterfall')\nconst CID = require('cids')\n\nconst util = require('./util')\n\nexports = module.exports\nexports.multicodec = 'dag-pb'\nexports.defaultHashAlg = 'sha2-256'\n\n/*\n * resolve: receives a path and a binary blob and returns the value on path,\n * throw if not possible. `binaryBlob` is the ProtocolBuffer encoded data.\n */\nexports.resolve = (binaryBlob, path, callback) => {\n  waterfall([\n    (cb) => util.deserialize(binaryBlob, cb),\n    (node, cb) => {\n      // Return the deserialized block if no path is given\n      if (!path) {\n        return callback(null, {\n          value: node,\n          remainderPath: ''\n        })\n      }\n\n      const split = path.split('/')\n\n      if (split[0] === 'Links') {\n        let remainderPath = ''\n\n        // all links\n        if (!split[1]) {\n          return cb(null, {\n            value: node.links.map((l) => l.toJSON()),\n            remainderPath: ''\n          })\n        }\n\n        // select one link\n\n        const values = {}\n\n        // populate both index number and name to enable both cases\n        // for the resolver\n        node.links.forEach((l, i) => {\n          const link = l.toJSON()\n          values[i] = values[link.name] = {\n            hash: link.multihash,\n            name: link.name,\n            size: link.size\n          }\n        })\n\n        let value = values[split[1]]\n\n        // if remainderPath exists, value needs to be CID\n        if (split[2] === 'Hash') {\n          value = { '/': value.hash }\n        } else if (split[2] === 'Tsize') {\n          value = value.size\n        } else if (split[2] === 'Name') {\n          value = value.name\n        }\n\n        remainderPath = split.slice(3).join('/')\n\n        cb(null, { value: value, remainderPath: remainderPath })\n      } else if (split[0] === 'Data') {\n        cb(null, { value: node.data, remainderPath: '' })\n      } else {\n        // If split[0] is not 'Data' or 'Links' then we might be trying to refer\n        // to a named link from the Links array. This is because go-ipfs and\n        // js-ipfs have historically supported the ability to do\n        // `ipfs dag get CID/a` where a is a named link in a dag-pb.\n        const values = {}\n\n        node.links.forEach((l, i) => {\n          const link = l.toJSON()\n          values[link.name] = {\n            hash: link.multihash,\n            name: link.name,\n            size: link.size\n          }\n        })\n\n        const value = values[split[0]]\n\n        if (value) {\n          return cb(null, {\n            value: { '/': value.hash },\n            remainderPath: split.slice(1).join('/')\n          })\n        }\n\n        cb(new Error('path not available'))\n      }\n    }\n  ], callback)\n}\n\n/*\n * tree: returns a flattened array with paths: values of the project. options\n * is an object that can carry several options (i.e. nestness)\n */\nexports.tree = (binaryBlob, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  options = options || {}\n\n  util.deserialize(binaryBlob, (err, node) => {\n    if (err) {\n      return callback(err)\n    }\n\n    const paths = []\n\n    paths.push('Links')\n\n    node.links.forEach((link, i) => {\n      paths.push(`Links/${i}/Name`)\n      paths.push(`Links/${i}/Tsize`)\n      paths.push(`Links/${i}/Hash`)\n    })\n\n    paths.push('Data')\n\n    callback(null, paths)\n  })\n}\n\n/*\n * isLink: returns the Link if a given path in a binary blob is a Link,\n * false otherwise\n */\nexports.isLink = (binaryBlob, path, callback) => {\n  exports.resolve(binaryBlob, path, (err, result) => {\n    if (err) {\n      return callback(err)\n    }\n\n    if (result.remainderPath.length > 0) {\n      return callback(new Error('path out of scope'))\n    }\n\n    if (typeof result.value === 'object' && result.value['/']) {\n      let valid\n      try {\n        valid = CID.isCID(new CID(result.value['/']))\n      } catch (err) {\n        valid = false\n      }\n      if (valid) {\n        return callback(null, result.value)\n      }\n    }\n\n    callback(null, false)\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}